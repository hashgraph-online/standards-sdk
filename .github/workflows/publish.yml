name: Publish Standards SDK

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, do not publish (use npm/pnpm dry-run)'
        required: false
        default: 'false'

concurrency:
  group: standards-sdk-publish-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  publish:
    name: Release SDK packages
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'
          cache: 'pnpm'

      - name: Determine publish plan
        id: plan
        shell: bash
        run: |
          set -euo pipefail

          DRY_RUN="${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}"
          echo "dry_run=$DRY_RUN" >> "$GITHUB_OUTPUT"

          latest_tag="$(git tag --list 'v*' --sort=-version:refname | head -n 1)"

          max_stable_version() {
            printf '%s\n' "$@" \
              | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' || true \
              | sort -V \
              | tail -n 1 || true
          }

          registry_max_stable_version_for_pkg() {
            local pkg="$1"
            local raw=""
            raw="$(npm --silent view "$pkg" versions --json 2>/dev/null || true)"
            if [ -z "$raw" ]; then
              return 1
            fi
            printf '%s' "$raw" | node -e 'const fs=require("fs"); const input=fs.readFileSync(0,"utf8").trim(); let versions=[]; try{ const parsed=JSON.parse(input); versions=Array.isArray(parsed)?parsed:[parsed]; }catch{ process.exit(1); } const parse=(v)=>{const m=/^(\\d+)\\.(\\d+)\\.(\\d+)$/.exec(String(v)); return m?[+m[1],+m[2],+m[3]]:null}; const cmp=(a,b)=>{for(let i=0;i<3;i+=1){if(a[i]>b[i])return 1;if(a[i]<b[i])return -1}return 0}; let best=null; for(const v of versions){const p=parse(v); if(!p) continue; if(!best||cmp(p,best)>0) best=p;} if(best) process.stdout.write(`${best[0]}.${best[1]}.${best[2]}`);'
          }

          registry_version_exists() {
            local pkg="$1"
            local version="$2"
            local out=""
            if ! out="$(npm --silent view "${pkg}@${version}" version --json 2>/dev/null)"; then
              return 1
            fi
            if [ "$out" = "\"$version\"" ] || [ "$out" = "$version" ]; then
              return 0
            fi
            return 1
          }

          registry_exists_pkg() {
            local pkg="$1"
            local version="$2"
            local attempt
            for attempt in 1 2 3 4 5 6 7 8; do
              if registry_version_exists "$pkg" "$version"; then
                return 0
              fi
              case "$?" in
                1) return 1 ;;
                *) sleep $((attempt * 2)) ;;
              esac
            done
            echo "Registry lookup failed for ${pkg}@${version}" >&2
            exit 1
          }

          registry_max_stable_version_retry() {
            local attempt
            for attempt in 1 2 3; do
              if registry_max_stable_version_for_pkg "$@"; then
                return 0
              fi
              sleep $((attempt * 2))
            done
            return 1
          }

          package_version="$(node -p "require('./package.json').version" 2>/dev/null || true)"
          registry_version="$(registry_max_stable_version_retry "@hashgraphonline/standards-sdk" || true)"
          base_version="$(max_stable_version "$package_version" "$registry_version")"

          bump_patch() {
            local input="$1"
            local major minor patch
            IFS='.' read -r major minor patch <<<"$input"
            if ! [[ "$major" =~ ^[0-9]+$ && "$minor" =~ ^[0-9]+$ && "$patch" =~ ^[0-9]+$ ]]; then
              echo "Invalid stable version: $input" >&2
              return 1
            fi
            echo "${major}.${minor}.$((patch + 1))"
          }

          tag_version=""
          if [ -n "$latest_tag" ]; then
            tag_version="${latest_tag#v}"
            base_version="$(max_stable_version "$base_version" "$tag_version")"
          fi

          mode="release"
          if [ -z "$base_version" ]; then
            echo "Failed to resolve base_version" >&2
            exit 1
          fi
          version="$(bump_patch "$base_version")"

          repair_tag=""
          if [ -n "$latest_tag" ] && [ -n "$tag_version" ]; then
            missing=false
            for pkg in "@hashgraphonline/standards-sdk" "@hol-org/standards-sdk" "@hol-org/rb-client"; do
              if ! registry_exists_pkg "$pkg" "$tag_version"; then
                missing=true
              fi
            done

            if [ "$missing" = "true" ]; then
              mode="repair"
              version="$tag_version"
              repair_tag="$latest_tag"
            fi
          fi

          if [ "$mode" = "release" ]; then
            while registry_exists_pkg "@hashgraphonline/standards-sdk" "$version" || registry_exists_pkg "@hol-org/standards-sdk" "$version" || registry_exists_pkg "@hol-org/rb-client" "$version"; do
              version="$(bump_patch "$version")"
            done
          fi

          echo "base_version=$base_version"
          echo "tag_version=$tag_version"
          echo "computed_version=$version"
          echo "mode=$mode" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=v$version" >> "$GITHUB_OUTPUT"
          echo "latest_tag=${latest_tag:-}" >> "$GITHUB_OUTPUT"
          echo "published_version=${registry_version:-}" >> "$GITHUB_OUTPUT"
          echo "repair_tag=$repair_tag" >> "$GITHUB_OUTPUT"

      - name: Checkout release tag (repair mode)
        if: steps.plan.outputs.mode == 'repair' && steps.plan.outputs.repair_tag != ''
        run: git checkout "${{ steps.plan.outputs.repair_tag }}"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm -r run build

      - name: Set versions
        id: version
        shell: bash
        run: |
          set -euo pipefail

          NEW_VERSION="${{ steps.plan.outputs.version }}"
          echo "new=$NEW_VERSION" >> "$GITHUB_OUTPUT"

          pnpm version "$NEW_VERSION" --no-git-tag-version
          NEW_VERSION="$NEW_VERSION" node -e "const fs=require('fs');const p='packages/hol-standards-sdk/package.json';const j=JSON.parse(fs.readFileSync(p,'utf8'));j.version=process.env.NEW_VERSION;fs.writeFileSync(p,JSON.stringify(j,null,2)+'\\n');"
          NEW_VERSION="$NEW_VERSION" node -e "const fs=require('fs');const p='packages/rb-client/package.json';const j=JSON.parse(fs.readFileSync(p,'utf8'));j.version=process.env.NEW_VERSION;fs.writeFileSync(p,JSON.stringify(j,null,2)+'\\n');"

      - name: Compute publish targets
        id: targets
        shell: bash
        run: |
          set -euo pipefail

          NEW_VERSION="${{ steps.version.outputs.new }}"

          exists_pkg() {
            local pkg="$1"
            local attempt
            local out=""
            for attempt in 1 2 3 4 5 6; do
              out="$(npm --silent view "${pkg}@${NEW_VERSION}" version --json 2>/dev/null || true)"
              if [ -n "$out" ]; then
                if [ "$out" = "\"$NEW_VERSION\"" ] || [ "$out" = "$NEW_VERSION" ]; then
                  return 0
                fi
                return 1
              fi
              sleep $((attempt * 2))
            done
            echo "npm view failed for ${pkg}@${NEW_VERSION}" >&2
            exit 1
          }

          publish_hash=true
          publish_hol=true
          publish_rb=true

          if exists_pkg "@hashgraphonline/standards-sdk"; then
            publish_hash=false
          fi
          if exists_pkg "@hol-org/standards-sdk"; then
            publish_hol=false
          fi
          if exists_pkg "@hol-org/rb-client"; then
            publish_rb=false
          fi

          publish_any=false
          if [ "$publish_hash" = "true" ] || [ "$publish_hol" = "true" ] || [ "$publish_rb" = "true" ]; then
            publish_any=true
          fi

          echo "publish_hash=$publish_hash" >> "$GITHUB_OUTPUT"
          echo "publish_hol=$publish_hol" >> "$GITHUB_OUTPUT"
          echo "publish_rb=$publish_rb" >> "$GITHUB_OUTPUT"
          echo "publish_any=$publish_any" >> "$GITHUB_OUTPUT"

      - name: Publish @hashgraphonline/standards-sdk
        if: steps.targets.outputs.publish_hash == 'true'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.plan.outputs.dry_run }}" = "true" ]; then
            pnpm publish --access public --no-git-checks --provenance --dry-run
          else
            pnpm publish --access public --no-git-checks --provenance
          fi

      - name: Publish @hol-org/standards-sdk
        if: steps.targets.outputs.publish_hol == 'true'
        working-directory: packages/hol-standards-sdk
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.plan.outputs.dry_run }}" = "true" ]; then
            npm publish --access public --provenance --dry-run
          else
            npm publish --access public --provenance
          fi

      - name: Publish @hol-org/rb-client
        if: steps.targets.outputs.publish_rb == 'true'
        working-directory: packages/rb-client
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.plan.outputs.dry_run }}" = "true" ]; then
            npm publish --access public --provenance --dry-run
          else
            npm publish --access public --provenance
          fi

      - name: Publish to JSR
        if: steps.targets.outputs.publish_any == 'true' && (github.event_name != 'workflow_dispatch' || inputs.dry_run != 'true')
        working-directory: packages/jsr-client
        run: |
          # Update jsr.json version to match
          NEW_VERSION="${{ steps.version.outputs.new }}"
          jq --arg v "$NEW_VERSION" '.version = $v' jsr.json > jsr.json.tmp && mv jsr.json.tmp jsr.json
          npx jsr publish --allow-dirty --allow-slow-types

      - name: Create Git tag
        if: steps.plan.outputs.mode == 'release' && steps.targets.outputs.publish_any == 'true' && (github.event_name != 'workflow_dispatch' || inputs.dry_run != 'true')
        run: |
          git tag "v${{ steps.version.outputs.new }}"
          git push --tags

      - name: Skip publish (already published)
        if: steps.targets.outputs.publish_any != 'true'
        run: echo "All packages for version ${{ steps.version.outputs.new }} already exist; skipping publish."
